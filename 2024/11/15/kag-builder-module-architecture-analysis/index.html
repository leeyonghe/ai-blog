<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<!-- 기본 SEO 메타 태그 -->
<title>KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진 | AI Development Blog</title>
<meta name="description" content="개요이번 포스트에서는 KAG Builder 모듈의 상세한 아키텍처를 분석합니다. Builder는 KAG 프레임워크의 핵심 구성 요소로, 다양한 문서 소스에서 지식을 추출하고 구조화된 지식 그래프를 구축하는 역할을 담당합니다.1. KAG Builder 개요1.1 Builder 모듈의...">
<meta name="author" content="David Lee">
<meta name="keywords" content="kag, knowledge-extraction, graph-building, nlp, document-processing">

<!-- 정규 URL -->
<link rel="canonical" href="https://leeyonghe.github.io/ai-blog/2024/11/15/kag-builder-module-architecture-analysis/">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="article">
<meta property="og:title" content="KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진">
<meta property="og:description" content="개요이번 포스트에서는 KAG Builder 모듈의 상세한 아키텍처를 분석합니다. Builder는 KAG 프레임워크의 핵심 구성 요소로, 다양한 문서 소스에서 지식을 추출하고 구조화된 지식 그래프를 구축하는 역할을 담당합니다.1. KAG Builder 개요1.1 Builder 모듈의...">
<meta property="og:url" content="https://leeyonghe.github.io/ai-blog/2024/11/15/kag-builder-module-architecture-analysis/">
<meta property="og:site_name" content="AI Development Blog">

<meta property="og:locale" content="ko_KR">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진">
<meta name="twitter:description" content="개요이번 포스트에서는 KAG Builder 모듈의 상세한 아키텍처를 분석합니다. Builder는 KAG 프레임워크의 핵심 구성 요소로, 다양한 문서 소스에서 지식을 추출하고 구조화된 지식 그래프를 구축하는 역할을 담당합니다.1. KAG Builder 개요1.1 Builder 모듈의...">



<!-- 검색 엔진 인증 메타 태그 -->



<!-- 언어 및 지역 설정 -->
<meta name="language" content="ko">
<meta name="geo.region" content="KR">
<meta name="geo.country" content="KR">

<!-- 추가 SEO 메타 태그 -->
<meta name="robots" content="index, follow">
<meta name="revisit-after" content="7 days">
<meta name="rating" content="general">

<!-- RSS 피드 -->
<link rel="alternate" type="application/rss+xml" title="AI Development Blog" href="https://leeyonghe.github.io/ai-blog/feed.xml">

<!-- 구조화된 데이터 (JSON-LD) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Blog",
  "name": "AI Development Blog",
  "description": "AI 개발 및 프레임워크 분석을 다루는 기술 블로그입니다. Rust, Python, AI/ML 프로젝트의 심층 분석과 실무 경험을 공유합니다.
",
  "url": "https://leeyonghe.github.io/ai-blog",
  "author": {
    "@type": "Person",
    "name": "David Lee",
    "email": "lee.yonghee.dev@gmail.com"
  },
  "inLanguage": "ko",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://leeyonghe.github.io/ai-blog/search?q={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}
</script>

<!-- 개별 포스트 구조화된 데이터 -->

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진",
  "description": "개요

이번 포스트에서는 KAG Builder 모듈의 상세한 아키텍처를 분석합니다. Builder는 KAG 프레임워크의 핵심 구성 요소로, 다양한 문서 소스에서 지식을 추출하고 구조화된 지식 그래프를 구축하는 역할을 담당합니다.

1. KAG Builder 개요

1.1 Build...",
  "image": "",
  "author": {
    "@type": "Person",
    "name": "David Lee"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AI Development Blog",
    "logo": {
      "@type": "ImageObject",
      "url": ""
    }
  },
  "datePublished": "2024-11-15T04:30:00+00:00",
  "dateModified": "2024-11-15T04:30:00+00:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://leeyonghe.github.io/ai-blog/2024/11/15/kag-builder-module-architecture-analysis/"
  },
  "url": "https://leeyonghe.github.io/ai-blog/2024/11/15/kag-builder-module-architecture-analysis/",
  "inLanguage": "ko",
  "keywords": ["kag","knowledge-extraction","graph-building","nlp","document-processing"],
  "articleSection": ["AI","Knowledge Graph","Data Processing"]
}
</script>

<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/ai-blog/assets/css/style.css">
<link rel="stylesheet" href="/ai-blog/assets/css/post-detail.css">
<style>
/* Post Detail Page Styling */
.post-container article {
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  padding: 40px;
  margin: 30px auto;
  max-width: 800px;
}

@media screen and (max-width: 768px) {
  .post-container article {
    margin: 20px;
    padding: 25px;
    border-radius: 8px;
  }
}

.post-container article .post-header {
  border-bottom: 2px solid #f5f5f5;
  padding-bottom: 25px;
  margin-bottom: 30px;
}

.post-container article .post-header .post-title {
  font-size: 2.2em;
  font-weight: 700;
  color: #2c3e50;
  line-height: 1.3;
  margin-bottom: 15px;
}

@media screen and (max-width: 768px) {
  .post-container article .post-header .post-title {
    font-size: 1.8em;
  }
}

.post-container article .post-header .post-meta {
  display: flex;
  align-items: center;
  gap: 20px;
  flex-wrap: wrap;
}

.post-container article .post-header .post-meta .post-date {
  display: flex;
  align-items: center;
  color: #666;
  font-size: 0.9em;
}

.post-container article .post-header .post-meta .post-date i {
  margin-right: 8px;
  color: #888;
}

.post-container article .post-header .post-meta .post-categories-wrapper {
  display: flex;
  align-items: center;
}

.post-container article .post-header .post-meta .post-categories-wrapper i {
  margin-right: 8px;
  color: #888;
}

.post-container article .post-header .post-meta .post-categories-wrapper .post-categories {
  display: flex;
  gap: 8px;
  list-style: none;
  margin: 0;
  padding: 0;
}

.post-container article .post-header .post-meta .post-categories-wrapper .post-categories li {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.8em;
  font-weight: 500;
  text-transform: capitalize;
}

.post-container article .post-content {
  font-size: 1.1em;
  line-height: 1.8;
  color: #333;
}

.post-container article .post-content p {
  margin-bottom: 1.2em;
}

.post-container article .post-content h1,
.post-container article .post-content h2,
.post-container article .post-content h3,
.post-container article .post-content h4,
.post-container article .post-content h5,
.post-container article .post-content h6 {
  color: #2c3e50;
  margin: 1.5em 0 0.8em 0;
  font-weight: 600;
}

.post-container article .post-content h2 {
  font-size: 1.8em;
  border-bottom: 2px solid #3498db;
  padding-bottom: 10px;
}

.post-container article .post-content h3 {
  font-size: 1.5em;
  color: #34495e;
}

.post-container article .post-content code {
  background: #f8f9fa;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.9em;
  color: #e74c3c;
}

.post-container article .post-content pre {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 15px;
  overflow-x: auto;
  margin: 1.5em 0;
}

.post-container article .post-content pre code {
  background: none;
  color: #333;
  padding: 0;
}

.post-container article .post-content blockquote {
  border-left: 4px solid #3498db;
  background: #f8f9fa;
  padding: 15px 20px;
  margin: 1.5em 0;
  font-style: italic;
  color: #555;
}

.post-container article .post-content img {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  margin: 1.5em 0;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.post-container article .post-content ul,
.post-container article .post-content ol {
  padding-left: 1.5em;
  margin-bottom: 1.2em;
}

.post-container article .post-content ul li,
.post-container article .post-content ol li {
  margin-bottom: 0.5em;
}

.post-container article .post-content a {
  color: #3498db;
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.3s ease;
}

.post-container article .post-content a:hover {
  border-bottom-color: #3498db;
}

.post-container article .post-footer {
  border-top: 2px solid #f5f5f5;
  padding-top: 25px;
  margin-top: 40px;
}

.post-container article .post-footer .post-navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 20px;
}

@media screen and (max-width: 768px) {
  .post-container article .post-footer .post-navigation {
    flex-direction: column;
    gap: 15px;
  }
}

.post-container article .post-footer .post-navigation .nav-previous,
.post-container article .post-footer .post-navigation .nav-next {
  flex: 1;
}

.post-container article .post-footer .post-navigation .nav-previous a,
.post-container article .post-footer .post-navigation .nav-next a {
  display: flex;
  align-items: center;
  padding: 15px 20px;
  background: #f8f9fa;
  border-radius: 8px;
  text-decoration: none;
  color: #333;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.post-container article .post-footer .post-navigation .nav-previous a:hover,
.post-container article .post-footer .post-navigation .nav-next a:hover {
  background: #e9ecef;
  border-color: #3498db;
  transform: translateY(-2px);
}

.post-container article .post-footer .post-navigation .nav-previous a i,
.post-container article .post-footer .post-navigation .nav-next a i {
  color: #3498db;
  margin: 0 8px;
}

.post-container article .post-footer .post-navigation .nav-previous a .nav-title,
.post-container article .post-footer .post-navigation .nav-next a .nav-title {
  font-weight: 500;
}

.post-container article .post-footer .post-navigation .nav-previous a {
  justify-content: flex-start;
}

.post-container article .post-footer .post-navigation .nav-next a {
  justify-content: flex-end;
  text-align: right;
}
</style>
<title>KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진</title>

<script type="text/javascript" src="/ai-blog/assets/js/darkmode.js"></script>


<!-- Mermaid Diagram Support -->
<script type="text/javascript" src="/ai-blog/assets/js/mermaid-init.js"></script>
<link rel="stylesheet" href="/ai-blog/assets/css/network-diagrams.css">
<style>
/* Mermaid diagram styling - Network optimized */
.mermaid {
  text-align: center;
  margin: 2em 0;
  padding: 1.5em;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  overflow-x: auto;
  position: relative;
}

.mermaid::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #3b82f6, #1d4ed8, #1e40af);
  border-radius: 12px 12px 0 0;
}

.mermaid svg {
  max-width: 100%;
  height: auto;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

/* Network diagram specific styling */
.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  stroke-width: 2px;
  filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.12));
}

.mermaid .edgePath path {
  stroke-width: 2px;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

.mermaid .cluster rect {
  stroke-width: 2px;
  stroke-dasharray: 5,5;
  opacity: 0.9;
}

/* Enhanced error styling */
.mermaid-error {
  color: #dc2626;
  background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
  border: 2px solid #fca5a5;
  border-radius: 12px;
  padding: 1.5em;
  text-align: center;
  font-style: italic;
  font-weight: 500;
  box-shadow: 0 4px 20px rgba(220, 38, 38, 0.1);
}

.mermaid-error::before {
  content: '⚠️ ';
  font-size: 1.2em;
  margin-right: 0.5em;
}

/* Loading animation */
.mermaid.loading {
  min-height: 200px;
  background: linear-gradient(
    90deg,
    #f1f5f9 25%,
    #e2e8f0 50%,
    #f1f5f9 75%
  );
  background-size: 200% 100%;
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

/* Responsive Mermaid diagrams */
@media (max-width: 768px) {
  .mermaid {
    font-size: 0.85em;
    padding: 1em;
    margin: 1.5em 0;
    border-radius: 8px;
  }

  .mermaid svg {
    transform: scale(0.9);
    transform-origin: center;
  }
}

@media (max-width: 480px) {
  .mermaid {
    font-size: 0.75em;
    padding: 0.8em;
    margin: 1em 0;
  }

  .mermaid svg {
    transform: scale(0.8);
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .mermaid {
    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
    border-color: #475569;
    color: #f1f5f9;
  }

  .mermaid::before {
    background: linear-gradient(90deg, #60a5fa, #3b82f6, #2563eb);
  }

  .mermaid-error {
    background: linear-gradient(135deg, #451a03 0%, #7c2d12 100%);
    border-color: #dc2626;
    color: #fef2f2;
  }
}

/* Print styles */
@media print {
  .mermaid {
    background: white !important;
    border: 1px solid #ccc !important;
    box-shadow: none !important;
    break-inside: avoid;
  }

  .mermaid::before {
    display: none !important;
  }
}
</style>
</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header condensed">
      <div class="about-title">
      <a href="/ai-blog/">
        
        <img src="/ai-blog/assets/portfolio.png" alt="David Lee" />
        
      </a>
      <h2 id="title">
        <a href="/ai-blog/">David Lee</a>
      </h2>
      </div><p class="tagline">Developer</p></div>
      
      <ul class="social about-footer condensed"><a href="https://github.com/leeyonghe" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://www.linkedin.com/in/lee-yong-hee-18912454/" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><!----></ul><p class="about-footer condensed">&copy;
        2025</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <style>
/* Post Detail Page Styling - Direct Inline */
.post-container article {
  background: #fff !important;
  border: none !important;
  border-top: none !important;
  border-right: none !important;
  border-bottom: none !important;
  border-left: none !important;
  border-width: 0 !important;
  border-style: none !important;
  outline: none !important;
  border-radius: 12px !important;
  box-shadow: none !important;
  padding: 40px !important;
  margin: 30px auto !important;
  max-width: 800px !important;
}

.post-container article .post-header .post-title {
  font-size: 2.2em !important;
  font-weight: 700 !important;
  color: #2c3e50 !important;
  line-height: 1.3 !important;
}

.post-container article .post-header {
  border-bottom: none !important;
  padding-bottom: 25px !important;
  margin-bottom: 30px !important;
}

.post-container article .post-content {
  font-size: 1.1em !important;
  line-height: 1.8 !important;
  color: #333 !important;
}

.post-container article .post-content h2 {
  font-size: 1.8em !important;
  border-bottom: none !important;
  padding-bottom: 10px !important;
  color: #2c3e50 !important;
}

.post-container article .post-header .post-meta .post-categories li {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  color: white !important;
  padding: 4px 12px !important;
  border-radius: 20px !important;
  font-size: 0.8em !important;
  list-style: none !important;
  display: inline-block !important;
  margin-right: 8px !important;
}

.post-container article .post-footer {
  border-top: none !important;
  padding-top: 25px !important;
  margin-top: 40px !important;
}

/* 모든 border와 box-shadow 강제 제거 */
.post-container article *,
.post-container article *::before,
.post-container article *::after {
  border: none !important;
  border-top: none !important;
  border-right: none !important;
  border-bottom: none !important;
  border-left: none !important;
  border-width: 0 !important;
  border-style: none !important;
  outline: none !important;
  box-shadow: none !important;
}

/* 코드 블록과 pre 태그도 border, box-shadow 제거 */
.post-container article pre,
.post-container article code,
.post-container article .highlight,
.post-container article .highlighter-rouge {
  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}
</style><div class="post-container">
  <article>
    <header class="post-header">
    <h1 class="post-title">KAG Builder 모듈 아키텍처 심층 분석 - 지식 추출 및 그래프 구축 엔진</h1>
    <div class="post-meta">
      <div class="post-date">
        <i class="icon-calendar"></i>
        <time datetime="2024-11-15T04:30:00+00:00">Nov 15, 2024</time>
      </div><div class="post-categories-wrapper">
        <i class="icon-tag"></i>
        <ul class="post-categories"><li>AI</li><li>Knowledge Graph</li><li>Data Processing</li></ul>
      </div></div>
  </header>

  <div class="post-content">
    <h2 id="개요">개요</h2>

<p>이번 포스트에서는 <strong>KAG Builder 모듈</strong>의 상세한 아키텍처를 분석합니다. Builder는 KAG 프레임워크의 핵심 구성 요소로, 다양한 문서 소스에서 지식을 추출하고 구조화된 지식 그래프를 구축하는 역할을 담당합니다.</p>

<h2 id="1-kag-builder-개요">1. KAG Builder 개요</h2>

<h3 id="11-builder-모듈의-역할">1.1 Builder 모듈의 역할</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># KAG Builder의 핵심 기능
</span><span class="n">kag</span><span class="o">/</span><span class="n">builder</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">main_builder</span><span class="p">.</span><span class="n">py</span>     <span class="c1"># 메인 빌더 진입점
</span><span class="err">├──</span> <span class="n">runner</span><span class="p">.</span><span class="n">py</span>           <span class="c1"># 실행 엔진 및 파이프라인
</span><span class="err">├──</span> <span class="n">default_chain</span><span class="p">.</span><span class="n">py</span>    <span class="c1"># 기본 처리 체인
</span><span class="err">└──</span> <span class="n">component</span><span class="o">/</span>          <span class="c1"># 핵심 처리 컴포넌트들
</span></code></pre></div></div>

<p><strong>Builder의 주요 임무:</strong></p>
<ul>
  <li><strong>문서 수집</strong>: 다양한 형식의 문서 읽기 및 파싱</li>
  <li><strong>지식 추출</strong>: 텍스트에서 엔티티 및 관계 추출</li>
  <li><strong>그래프 구축</strong>: 추출된 지식을 그래프 구조로 변환</li>
  <li><strong>인덱싱</strong>: 검색 및 추론을 위한 인덱스 생성</li>
</ul>

<h3 id="12-전체-처리-파이프라인">1.2 전체 처리 파이프라인</h3>

<pre><code class="language-mermaid">graph TD
    A[문서 입력] --&gt; B[Reader Components]
    B --&gt; C[Scanner Components]
    C --&gt; D[Splitter Components]
    D --&gt; E[Extractor Components]
    E --&gt; F[Aligner Components]
    F --&gt; G[Mapping Components]
    G --&gt; H[Vectorizer Components]
    H --&gt; I[Writer Components]
    I --&gt; J[지식 그래프 출력]
    
    subgraph "후처리"
        K[Postprocessor]
        L[External Graph Integration]
    end
    
    I --&gt; K
    K --&gt; L
    L --&gt; M[최종 지식베이스]
</code></pre>

<h2 id="2-핵심-컴포넌트-아키텍처">2. 핵심 컴포넌트 아키텍처</h2>

<h3 id="21-컴포넌트-구조-개요">2.1 컴포넌트 구조 개요</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kag</span><span class="o">/</span><span class="n">builder</span><span class="o">/</span><span class="n">component</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">reader</span><span class="o">/</span>              <span class="c1"># 문서 읽기 및 파싱
</span><span class="err">├──</span> <span class="n">scanner</span><span class="o">/</span>             <span class="c1"># 문서 스캔 및 메타데이터 추출
</span><span class="err">├──</span> <span class="n">splitter</span><span class="o">/</span>            <span class="c1"># 문서 분할 및 청킹
</span><span class="err">├──</span> <span class="n">extractor</span><span class="o">/</span>           <span class="c1"># 지식 추출 (NER, 관계 추출)
</span><span class="err">├──</span> <span class="n">aligner</span><span class="o">/</span>             <span class="c1"># 엔티티 정렬 및 정규화
</span><span class="err">├──</span> <span class="n">mapping</span><span class="o">/</span>             <span class="c1"># 스키마 매핑 및 변환
</span><span class="err">├──</span> <span class="n">vectorizer</span><span class="o">/</span>          <span class="c1"># 벡터 임베딩 생성
</span><span class="err">├──</span> <span class="n">writer</span><span class="o">/</span>              <span class="c1"># 결과 저장 및 출력
</span><span class="err">├──</span> <span class="n">postprocessor</span><span class="o">/</span>       <span class="c1"># 후처리 및 검증
</span><span class="err">└──</span> <span class="n">external_graph</span><span class="o">/</span>      <span class="c1"># 외부 그래프 통합
</span></code></pre></div></div>

<h3 id="22-컴포넌트-간-데이터-플로우">2.2 컴포넌트 간 데이터 플로우</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 빌더 체인에서의 데이터 전달 구조
</span><span class="k">class</span> <span class="nc">BuilderComponentData</span><span class="p">:</span>
    <span class="s">"""컴포넌트 간 전달되는 데이터 구조"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>           <span class="c1"># 텍스트 청크들
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">sub_graphs</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># 서브 그래프들
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># 추출된 엔티티들
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">relationships</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># 추출된 관계들
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">embeddings</span> <span class="o">=</span> <span class="p">{}</span>       <span class="c1"># 벡터 임베딩들
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>         <span class="c1"># 메타데이터
</span></code></pre></div></div>

<h2 id="3-reader-컴포넌트---문서-입력-처리">3. Reader 컴포넌트 - 문서 입력 처리</h2>

<h3 id="31-다양한-문서-형식-지원">3.1 다양한 문서 형식 지원</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kag</span><span class="o">/</span><span class="n">builder</span><span class="o">/</span><span class="n">component</span><span class="o">/</span><span class="n">reader</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">pdf_reader</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># PDF 문서 처리
</span><span class="err">├──</span> <span class="n">docx_reader</span><span class="p">.</span><span class="n">py</span>       <span class="c1"># Word 문서 처리
</span><span class="err">├──</span> <span class="n">txt_reader</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># 텍스트 파일 처리
</span><span class="err">├──</span> <span class="n">markdown_reader</span><span class="p">.</span><span class="n">py</span>   <span class="c1"># Markdown 처리
</span><span class="err">├──</span> <span class="n">dict_reader</span><span class="p">.</span><span class="n">py</span>       <span class="c1"># 딕셔너리 데이터 처리
</span><span class="err">├──</span> <span class="n">mix_reader</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># 혼합 형식 처리
</span><span class="err">└──</span> <span class="n">markdown_to_graph</span><span class="p">.</span><span class="n">py</span> <span class="c1"># Markdown → Graph 직접 변환
</span></code></pre></div></div>

<h3 id="32-pdf-reader-상세-분석">3.2 PDF Reader 상세 분석</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PDFReader</span><span class="p">(</span><span class="n">ReaderABC</span><span class="p">):</span>
    <span class="s">"""PDF 문서 전문 리더"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">llm_client</span> <span class="o">=</span> <span class="n">LLMClient</span><span class="p">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">outline_prompt</span> <span class="o">=</span> <span class="n">OutlinePrompt</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length_splitter</span> <span class="o">=</span> <span class="n">LengthSplitter</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="n">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Output</span><span class="p">:</span>
        <span class="s">"""PDF 처리 메인 로직"""</span>
        <span class="c1"># 1. PDF 메타데이터 추출
</span>        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_pdf_metadata</span><span class="p">(</span><span class="nb">input</span><span class="p">.</span><span class="n">file_path</span><span class="p">)</span>
        
        <span class="c1"># 2. 텍스트 추출
</span>        <span class="n">pages</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_text_from_pdf</span><span class="p">(</span><span class="nb">input</span><span class="p">.</span><span class="n">file_path</span><span class="p">)</span>
        
        <span class="c1"># 3. 구조화 (목차, 섹션 분석)
</span>        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_analyze_document_structure</span><span class="p">(</span><span class="n">pages</span><span class="p">)</span>
        
        <span class="c1"># 4. 청크 생성
</span>        <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_create_chunks</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Output</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_extract_text_from_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LTPage</span><span class="p">]:</span>
        <span class="s">"""PDF에서 텍스트 추출"""</span>
        <span class="n">pages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">page_layout</span> <span class="ow">in</span> <span class="n">extract_pages</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="n">page_text</span> <span class="o">=</span> <span class="s">""</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">page_layout</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">LTTextContainer</span><span class="p">):</span>
                    <span class="n">page_text</span> <span class="o">+=</span> <span class="n">element</span><span class="p">.</span><span class="n">get_text</span><span class="p">()</span>
            <span class="n">pages</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">page_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pages</span>
    
    <span class="k">def</span> <span class="nf">_analyze_document_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pages</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="s">"""LLM을 활용한 문서 구조 분석"""</span>
        <span class="n">combined_text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">pages</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># 처음 5페이지 분석
</span>        
        <span class="n">prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">outline_prompt</span><span class="p">.</span><span class="n">build_prompt</span><span class="p">(</span><span class="n">combined_text</span><span class="p">)</span>
        <span class="n">structure_response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">llm_client</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_parse_structure_response</span><span class="p">(</span><span class="n">structure_response</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="33-지능형-문서-구조-인식">3.3 지능형 문서 구조 인식</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OutlinePrompt</span><span class="p">:</span>
    <span class="s">"""문서 구조 분석을 위한 프롬프트"""</span>
    
    <span class="k">def</span> <span class="nf">build_prompt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"""
        다음 문서의 구조를 분석하고 목차를 추출하세요:
        
        문서 내용:
        </span><span class="si">{</span><span class="n">document_text</span><span class="si">}</span><span class="s">
        
        분석 결과를 다음 JSON 형식으로 반환하세요:
        title,
                ...
            ],
            "document_type": "논문|보고서|매뉴얼|기타"
        }}
        """</span>
</code></pre></div></div>

<h2 id="4-extractor-컴포넌트---지식-추출">4. Extractor 컴포넌트 - 지식 추출</h2>

<h3 id="41-추출기-유형별-분류">4.1 추출기 유형별 분류</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kag</span><span class="o">/</span><span class="n">builder</span><span class="o">/</span><span class="n">component</span><span class="o">/</span><span class="n">extractor</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">entity_extractor</span><span class="p">.</span><span class="n">py</span>     <span class="c1"># 개체명 인식 (NER)
</span><span class="err">├──</span> <span class="n">relation_extractor</span><span class="p">.</span><span class="n">py</span>   <span class="c1"># 관계 추출
</span><span class="err">├──</span> <span class="n">concept_extractor</span><span class="p">.</span><span class="n">py</span>    <span class="c1"># 개념 추출
</span><span class="err">├──</span> <span class="n">event_extractor</span><span class="p">.</span><span class="n">py</span>      <span class="c1"># 이벤트 추출
</span><span class="err">├──</span> <span class="n">llm_extractor</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># LLM 기반 통합 추출
</span><span class="err">└──</span> <span class="n">schema_extractor</span><span class="p">.</span><span class="n">py</span>     <span class="c1"># 스키마 기반 추출
</span></code></pre></div></div>

<h3 id="42-llm-기반-지식-추출기">4.2 LLM 기반 지식 추출기</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LLMKnowledgeExtractor</span><span class="p">:</span>
    <span class="s">"""LLM을 활용한 통합 지식 추출기"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">llm_client</span> <span class="o">=</span> <span class="n">LLMClient</span><span class="p">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">extraction_prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_load_extraction_prompts</span><span class="p">()</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">extract_knowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk</span><span class="p">:</span> <span class="n">Chunk</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubGraph</span><span class="p">:</span>
        <span class="s">"""텍스트 청크에서 지식 추출"""</span>
        
        <span class="c1"># 1. 엔티티 추출
</span>        <span class="n">entities</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_entities</span><span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">content</span><span class="p">)</span>
        
        <span class="c1"># 2. 관계 추출  
</span>        <span class="n">relationships</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_relationships</span><span class="p">(</span>
            <span class="n">chunk</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">entities</span>
        <span class="p">)</span>
        
        <span class="c1"># 3. 서브그래프 구성
</span>        <span class="n">sub_graph</span> <span class="o">=</span> <span class="n">SubGraph</span><span class="p">()</span>
        
        <span class="c1"># 노드 추가
</span>        <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">generate_hash_id</span><span class="p">(</span><span class="n">entity</span><span class="p">[</span><span class="s">'name'</span><span class="p">]),</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">entity</span><span class="p">[</span><span class="s">'type'</span><span class="p">],</span>
                <span class="n">properties</span><span class="o">=</span><span class="n">entity</span><span class="p">[</span><span class="s">'properties'</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">sub_graph</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># 엣지 추가
</span>        <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">relationships</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span>
                <span class="n">source_id</span><span class="o">=</span><span class="n">rel</span><span class="p">[</span><span class="s">'source'</span><span class="p">],</span>
                <span class="n">target_id</span><span class="o">=</span><span class="n">rel</span><span class="p">[</span><span class="s">'target'</span><span class="p">],</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">rel</span><span class="p">[</span><span class="s">'type'</span><span class="p">],</span>
                <span class="n">properties</span><span class="o">=</span><span class="n">rel</span><span class="p">[</span><span class="s">'properties'</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">sub_graph</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sub_graph</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_extract_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="s">"""엔티티 추출"""</span>
        <span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"""
        다음 텍스트에서 주요 엔티티를 추출하세요:
        
        텍스트: </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s">
        
        다음 형식으로 반환하세요:
        [
            name
            }}
        ]
        """</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">llm_client</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_parse_entities</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_extract_relationships</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="s">"""관계 추출"""</span>
        <span class="n">entity_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s">'name'</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">]</span>
        
        <span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"""
        다음 텍스트에서 엔티티들 간의 관계를 추출하세요:
        
        텍스트: </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s">
        엔티티들: </span><span class="si">{</span><span class="n">entity_names</span><span class="si">}</span><span class="s">
        
        관계를 다음 형식으로 반환하세요:
        [
            source
            }}
        ]
        """</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">llm_client</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_parse_relationships</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="43-스키마-기반-추출">4.3 스키마 기반 추출</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SchemaBasedExtractor</span><span class="p">:</span>
    <span class="s">"""도메인 특화 스키마 기반 추출기"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema_config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">entity_schema</span> <span class="o">=</span> <span class="n">schema_config</span><span class="p">[</span><span class="s">'entities'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">relation_schema</span> <span class="o">=</span> <span class="n">schema_config</span><span class="p">[</span><span class="s">'relations'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">extraction_rules</span> <span class="o">=</span> <span class="n">schema_config</span><span class="p">[</span><span class="s">'rules'</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">extract_with_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubGraph</span><span class="p">:</span>
        <span class="s">"""스키마에 따른 구조화된 추출"""</span>
        
        <span class="n">sub_graph</span> <span class="o">=</span> <span class="n">SubGraph</span><span class="p">()</span>
        
        <span class="c1"># 스키마 정의된 엔티티 타입별 추출
</span>        <span class="k">for</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">schema</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">entity_schema</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">entities</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_typed_entities</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_create_schema_node</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                <span class="n">sub_graph</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># 스키마 정의된 관계 추출
</span>        <span class="k">for</span> <span class="n">relation_type</span><span class="p">,</span> <span class="n">schema</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">relation_schema</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">relations</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_extract_typed_relations</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">relation_type</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">relations</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_create_schema_edge</span><span class="p">(</span><span class="n">relation</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                <span class="n">sub_graph</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sub_graph</span>
</code></pre></div></div>

<h2 id="5-splitter-컴포넌트---텍스트-분할">5. Splitter 컴포넌트 - 텍스트 분할</h2>

<h3 id="51-다양한-분할-전략">5.1 다양한 분할 전략</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kag</span><span class="o">/</span><span class="n">builder</span><span class="o">/</span><span class="n">component</span><span class="o">/</span><span class="n">splitter</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">length_splitter</span><span class="p">.</span><span class="n">py</span>      <span class="c1"># 길이 기반 분할
</span><span class="err">├──</span> <span class="n">semantic_splitter</span><span class="p">.</span><span class="n">py</span>    <span class="c1"># 의미 기반 분할
</span><span class="err">├──</span> <span class="n">sentence_splitter</span><span class="p">.</span><span class="n">py</span>    <span class="c1"># 문장 단위 분할
</span><span class="err">├──</span> <span class="n">paragraph_splitter</span><span class="p">.</span><span class="n">py</span>   <span class="c1"># 단락 단위 분할
</span><span class="err">└──</span> <span class="n">hybrid_splitter</span><span class="p">.</span><span class="n">py</span>      <span class="c1"># 하이브리드 분할
</span></code></pre></div></div>

<h3 id="52-의미-기반-지능형-분할">5.2 의미 기반 지능형 분할</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SemanticSplitter</span><span class="p">:</span>
    <span class="s">"""의미 단위 기반 텍스트 분할기"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">max_chunk_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'max_chunk_size'</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">overlap_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'overlap_size'</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">embedding_model</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'embedding_model'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">similarity_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'similarity_threshold'</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">split_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Chunk</span><span class="p">]:</span>
        <span class="s">"""의미 기반 텍스트 분할"""</span>
        
        <span class="c1"># 1. 문장 단위로 1차 분할
</span>        <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_split_into_sentences</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        
        <span class="c1"># 2. 문장들의 임베딩 계산
</span>        <span class="n">embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_compute_embeddings</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
        
        <span class="c1"># 3. 의미적 유사도 기반 클러스터링
</span>        <span class="n">clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_semantic_clustering</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">)</span>
        
        <span class="c1"># 4. 클러스터를 청크로 변환
</span>        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">chunk_text</span> <span class="o">=</span> <span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s">'sentences'</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_text</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">max_chunk_size</span><span class="p">:</span>
                <span class="n">chunks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Chunk</span><span class="p">(</span>
                    <span class="n">content</span><span class="o">=</span><span class="n">chunk_text</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="p">{</span>
                        <span class="s">'semantic_cluster_id'</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s">'id'</span><span class="p">],</span>
                        <span class="s">'coherence_score'</span><span class="p">:</span> <span class="n">cluster</span><span class="p">[</span><span class="s">'coherence'</span><span class="p">],</span>
                        <span class="s">'sentence_count'</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s">'sentences'</span><span class="p">])</span>
                    <span class="p">}</span>
                <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 너무 큰 클러스터는 재분할
</span>                <span class="n">sub_chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_split_large_cluster</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="n">chunks</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_chunks</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">chunks</span>
    
    <span class="k">def</span> <span class="nf">_semantic_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
        <span class="s">"""의미적 유사도 기반 문장 클러스터링"""</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_cluster</span> <span class="o">=</span> <span class="p">{</span><span class="s">'sentences'</span><span class="p">:</span> <span class="p">[</span><span class="n">sentences</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s">'embeddings'</span><span class="p">:</span> <span class="p">[</span><span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]]}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)):</span>
            <span class="c1"># 현재 클러스터와의 평균 유사도 계산
</span>            <span class="n">avg_similarity</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_calculate_cluster_similarity</span><span class="p">(</span>
                <span class="n">embeddings</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">current_cluster</span><span class="p">[</span><span class="s">'embeddings'</span><span class="p">]</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">avg_similarity</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">similarity_threshold</span><span class="p">:</span>
                <span class="c1"># 현재 클러스터에 추가
</span>                <span class="n">current_cluster</span><span class="p">[</span><span class="s">'sentences'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">sentences</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">current_cluster</span><span class="p">[</span><span class="s">'embeddings'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">embeddings</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 새 클러스터 시작
</span>                <span class="n">clusters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_finalize_cluster</span><span class="p">(</span><span class="n">current_cluster</span><span class="p">))</span>
                <span class="n">current_cluster</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s">'sentences'</span><span class="p">:</span> <span class="p">[</span><span class="n">sentences</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                    <span class="s">'embeddings'</span><span class="p">:</span> <span class="p">[</span><span class="n">embeddings</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="p">}</span>
        
        <span class="n">clusters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_finalize_cluster</span><span class="p">(</span><span class="n">current_cluster</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">clusters</span>
</code></pre></div></div>

<h2 id="6-vectorizer-컴포넌트---임베딩-생성">6. Vectorizer 컴포넌트 - 임베딩 생성</h2>

<h3 id="61-다중-임베딩-전략">6.1 다중 임베딩 전략</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MultiModalVectorizer</span><span class="p">:</span>
    <span class="s">"""다중 모달 벡터화 엔진"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">text_embedder</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_init_text_embedder</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph_embedder</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_init_graph_embedder</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fusion_strategy</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'fusion_strategy'</span><span class="p">,</span> <span class="s">'concatenation'</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">vectorize_knowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_graph</span><span class="p">:</span> <span class="n">SubGraph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="s">"""지식 그래프의 다중 임베딩 생성"""</span>
        
        <span class="n">embeddings</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># 1. 텍스트 임베딩
</span>        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sub_graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">text_emb</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">text_embedder</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">properties</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'description'</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
            <span class="n">embeddings</span><span class="p">[</span><span class="sa">f</span><span class="s">"text_</span><span class="si">{</span><span class="n">node</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">text_emb</span>
        
        <span class="c1"># 2. 그래프 구조 임베딩
</span>        <span class="n">graph_emb</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph_embedder</span><span class="p">.</span><span class="n">encode_graph</span><span class="p">(</span><span class="n">sub_graph</span><span class="p">)</span>
        <span class="n">embeddings</span><span class="p">[</span><span class="s">'graph_structure'</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_emb</span>
        
        <span class="c1"># 3. 노드 임베딩 (GraphSAGE, Node2Vec 등)
</span>        <span class="n">node_embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_compute_node_embeddings</span><span class="p">(</span><span class="n">sub_graph</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">emb</span> <span class="ow">in</span> <span class="n">node_embeddings</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">embeddings</span><span class="p">[</span><span class="sa">f</span><span class="s">"node_</span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">emb</span>
        
        <span class="c1"># 4. 관계 임베딩
</span>        <span class="n">relation_embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_compute_relation_embeddings</span><span class="p">(</span><span class="n">sub_graph</span><span class="p">)</span>
        <span class="n">embeddings</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">relation_embeddings</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">embeddings</span>
    
    <span class="k">def</span> <span class="nf">_compute_node_embeddings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_graph</span><span class="p">:</span> <span class="n">SubGraph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="s">"""노드 임베딩 계산 (Graph Neural Network 기반)"""</span>
        
        <span class="c1"># NetworkX 그래프로 변환
</span>        <span class="n">nx_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_to_networkx</span><span class="p">(</span><span class="n">sub_graph</span><span class="p">)</span>
        
        <span class="c1"># Node2Vec 임베딩
</span>        <span class="kn">from</span> <span class="nn">node2vec</span> <span class="kn">import</span> <span class="n">Node2Vec</span>
        
        <span class="n">node2vec</span> <span class="o">=</span> <span class="n">Node2Vec</span><span class="p">(</span>
            <span class="n">nx_graph</span><span class="p">,</span> 
            <span class="n">dimensions</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
            <span class="n">num_walks</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
            <span class="n">workers</span><span class="o">=</span><span class="mi">4</span>
        <span class="p">)</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">node2vec</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_words</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="n">embeddings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">nx_graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">embeddings</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">wv</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span>
            <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
                <span class="c1"># 임베딩이 없는 경우 영벡터
</span>                <span class="n">embeddings</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">embeddings</span>
</code></pre></div></div>

<h2 id="7-writer-컴포넌트---결과-저장">7. Writer 컴포넌트 - 결과 저장</h2>

<h3 id="71-다중-저장-백엔드-지원">7.1 다중 저장 백엔드 지원</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MultiBackendWriter</span><span class="p">:</span>
    <span class="s">"""다중 백엔드 동시 저장"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">neo4j_writer</span> <span class="o">=</span> <span class="n">Neo4jGraphWriter</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s">'neo4j'</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">es_writer</span> <span class="o">=</span> <span class="n">ElasticsearchWriter</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s">'elasticsearch'</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">vector_writer</span> <span class="o">=</span> <span class="n">VectorDBWriter</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s">'vector_db'</span><span class="p">])</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">write_knowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_graphs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SubGraph</span><span class="p">],</span> <span class="n">embeddings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="s">"""지식을 다중 백엔드에 동시 저장"""</span>
        
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># 1. Neo4j에 그래프 구조 저장
</span>        <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_write_to_neo4j</span><span class="p">(</span><span class="n">sub_graphs</span><span class="p">))</span>
        
        <span class="c1"># 2. Elasticsearch에 검색 인덱스 저장  
</span>        <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_write_to_elasticsearch</span><span class="p">(</span><span class="n">sub_graphs</span><span class="p">))</span>
        
        <span class="c1"># 3. 벡터 DB에 임베딩 저장
</span>        <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_write_to_vector_db</span><span class="p">(</span><span class="n">embeddings</span><span class="p">))</span>
        
        <span class="c1"># 병렬 실행
</span>        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># 결과 검증 및 오류 처리
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_handle_write_results</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_write_to_neo4j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_graphs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SubGraph</span><span class="p">]):</span>
        <span class="s">"""Neo4j 그래프 저장"""</span>
        <span class="k">for</span> <span class="n">sub_graph</span> <span class="ow">in</span> <span class="n">sub_graphs</span><span class="p">:</span>
            <span class="c1"># 노드 저장
</span>            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sub_graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">neo4j_writer</span><span class="p">.</span><span class="n">create_node</span><span class="p">(</span>
                    <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="nb">type</span><span class="p">],</span>
                    <span class="n">properties</span><span class="o">=</span><span class="n">node</span><span class="p">.</span><span class="n">properties</span>
                <span class="p">)</span>
            
            <span class="c1"># 관계 저장
</span>            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">sub_graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">neo4j_writer</span><span class="p">.</span><span class="n">create_relationship</span><span class="p">(</span>
                    <span class="n">source_id</span><span class="o">=</span><span class="n">edge</span><span class="p">.</span><span class="n">source_id</span><span class="p">,</span>
                    <span class="n">target_id</span><span class="o">=</span><span class="n">edge</span><span class="p">.</span><span class="n">target_id</span><span class="p">,</span>
                    <span class="n">relation_type</span><span class="o">=</span><span class="n">edge</span><span class="p">.</span><span class="nb">type</span><span class="p">,</span>
                    <span class="n">properties</span><span class="o">=</span><span class="n">edge</span><span class="p">.</span><span class="n">properties</span>
                <span class="p">)</span>
</code></pre></div></div>

<h2 id="8-builder-실행-엔진">8. Builder 실행 엔진</h2>

<h3 id="81-파이프라인-실행기">8.1 파이프라인 실행기</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BuilderChainStreamRunner</span><span class="p">:</span>
    <span class="s">"""스트림 기반 빌더 체인 실행기"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BuilderComponent</span><span class="p">]):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">checkpointer</span> <span class="o">=</span> <span class="n">CheckpointerManager</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">progress_tracker</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">()</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">run_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">:</span> <span class="n">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Output</span><span class="p">:</span>
        <span class="s">"""전체 파이프라인 실행"""</span>
        
        <span class="n">current_data</span> <span class="o">=</span> <span class="n">BuilderComponentData</span><span class="p">()</span>
        <span class="n">current_data</span><span class="p">.</span><span class="nb">input</span> <span class="o">=</span> <span class="n">input_data</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># 체크포인트 복원
</span>                <span class="n">checkpoint_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"component_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">component</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">"</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">checkpointer</span><span class="p">.</span><span class="n">has_checkpoint</span><span class="p">(</span><span class="n">checkpoint_key</span><span class="p">):</span>
                    <span class="n">current_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">checkpointer</span><span class="p">.</span><span class="n">restore</span><span class="p">(</span><span class="n">checkpoint_key</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 컴포넌트 실행
</span>                    <span class="n">current_data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_run_component</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">current_data</span><span class="p">)</span>
                    
                    <span class="c1"># 체크포인트 저장
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">checkpointer</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">checkpoint_key</span><span class="p">,</span> <span class="n">current_data</span><span class="p">)</span>
                
                <span class="c1"># 진행 상황 업데이트
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">progress_tracker</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s">"Component </span><span class="si">{</span><span class="n">component</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_handle_component_failure</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">current_data</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_finalize_output</span><span class="p">(</span><span class="n">current_data</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_run_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="n">BuilderComponent</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">BuilderComponentData</span><span class="p">):</span>
        <span class="s">"""개별 컴포넌트 실행"""</span>
        
        <span class="c1"># 컴포넌트별 병렬 처리
</span>        <span class="k">if</span> <span class="n">component</span><span class="p">.</span><span class="n">supports_parallel</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_run_parallel</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">component</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_run_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="n">BuilderComponent</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">BuilderComponentData</span><span class="p">):</span>
        <span class="s">"""병렬 처리 실행"""</span>
        
        <span class="c1"># 입력 데이터 분할
</span>        <span class="n">batches</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_split_data_for_parallel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="n">batch_size</span><span class="p">)</span>
        
        <span class="c1"># 병렬 실행
</span>        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">component</span><span class="p">.</span><span class="n">max_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="n">invoke</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span>
                <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">tasks</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">wrap_future</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s">"Batch processing failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        
        <span class="c1"># 결과 병합
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_merge_parallel_results</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="9-성능-최적화-및-확장성">9. 성능 최적화 및 확장성</h2>

<h3 id="91-메모리-효율적-스트림-처리">9.1 메모리 효율적 스트림 처리</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamProcessor</span><span class="p">:</span>
    <span class="s">"""메모리 효율적인 스트림 처리"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">processing_queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">process_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_stream</span><span class="p">):</span>
        <span class="s">"""스트림 데이터 처리"""</span>
        
        <span class="c1"># 생산자-소비자 패턴
</span>        <span class="n">producer_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_produce_chunks</span><span class="p">(</span><span class="n">data_stream</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="n">consumer_tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_consume_chunks</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 4개 소비자
</span>        <span class="p">]</span>
        
        <span class="c1"># 모든 작업 완료 대기
</span>        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="n">producer_task</span><span class="p">,</span> <span class="o">*</span><span class="n">consumer_tasks</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_produce_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_stream</span><span class="p">):</span>
        <span class="s">"""데이터 청크 생산"""</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">data_stream</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">processing_queue</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        
        <span class="c1"># 종료 신호
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">processing_queue</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_consume_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""데이터 청크 소비 및 처리"""</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">processing_queue</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="c1"># 청크 처리
</span>            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_process_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">processing_queue</span><span class="p">.</span><span class="n">task_done</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="92-분산-처리-지원">9.2 분산 처리 지원</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DistributedBuilder</span><span class="p">:</span>
    <span class="s">"""분산 빌더 처리"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">worker_nodes</span> <span class="o">=</span> <span class="n">cluster_config</span><span class="p">[</span><span class="s">'workers'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">coordinator</span> <span class="o">=</span> <span class="n">cluster_config</span><span class="p">[</span><span class="s">'coordinator'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">task_scheduler</span> <span class="o">=</span> <span class="n">DistributedTaskScheduler</span><span class="p">()</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">distributed_build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">large_dataset</span><span class="p">):</span>
        <span class="s">"""대규모 데이터셋 분산 처리"""</span>
        
        <span class="c1"># 1. 데이터 파티셔닝
</span>        <span class="n">partitions</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_partition_dataset</span><span class="p">(</span><span class="n">large_dataset</span><span class="p">)</span>
        
        <span class="c1"># 2. 워커 노드에 작업 분배
</span>        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">task_scheduler</span><span class="p">.</span><span class="n">get_available_worker</span><span class="p">()</span>
            <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_submit_partition_task</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
            <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        
        <span class="c1"># 3. 분산 실행 및 결과 수집
</span>        <span class="n">partial_results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
        
        <span class="c1"># 4. 결과 병합 및 후처리
</span>        <span class="n">final_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_merge_distributed_results</span><span class="p">(</span><span class="n">partial_results</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">final_result</span>
</code></pre></div></div>

<h2 id="결론">결론</h2>

<p>KAG Builder 모듈은 <strong>모듈화된 컴포넌트 아키텍처</strong>와 <strong>지능형 처리 파이프라인</strong>을 통해 복잡한 지식 추출 및 그래프 구축 작업을 효율적으로 수행합니다.</p>

<p><strong>핵심 혁신 포인트:</strong></p>
<ul>
  <li><strong>다형성 지원</strong>: 다양한 문서 형식과 데이터 소스 처리</li>
  <li><strong>LLM 통합</strong>: 대규모 언어 모델을 활용한 지능형 추출</li>
  <li><strong>병렬 처리</strong>: 고성능 분산 처리 아키텍처</li>
  <li><strong>확장성</strong>: 플러그인 방식의 컴포넌트 확장</li>
</ul>

<p>다음 포스트에서는 KAG Solver 모듈의 추론 엔진과 질의 처리 시스템을 상세히 분석하겠습니다.</p>

<hr />

<p><strong>연관 포스트:</strong></p>
<ul>
  <li><a href="/2024/08/15/kag-project-overview-architecture-analysis/">KAG (Knowledge Augmented Generation) 프로젝트 개요 및 아키텍처 심층 분석</a></li>
  <li><a href="/2025/02/28/kag-docker-container-orchestration-analysis/">KAG Docker 컨테이너 오케스트레이션 및 마이크로서비스 아키텍처 심층 분석</a></li>
</ul>

<p><strong>참고 자료:</strong></p>
<ul>
  <li><a href="https://python.langchain.com/docs/modules/data_connection/document_loaders/">LangChain 문서 처리</a></li>
  <li><a href="https://networkx.org/">NetworkX 그래프 라이브러리</a></li>
  <li><a href="https://github.com/aditya-grover/node2vec">Node2Vec 그래프 임베딩</a></li>
  <li><a href="https://github.com/pdfminer/pdfminer.six">PDFMiner Python 라이브러리</a></li>
</ul>

  </div>

  <footer class="post-footer">
    <div class="post-navigation"><div class="nav-previous">
        <a href="/ai-blog/2024/11/08/foundation-models-evaluation-optimization/" rel="prev">
          <i class="icon-left-arrow"></i>
          <span class="nav-title">파운데이션 모델 이해하기 (4부) - 평가 방법론과 성능 최적화 심층 분석</span>
        </a>
      </div><div class="nav-next">
        <a href="/ai-blog/2024/11/15/audiocraft-custom-comprehensive-analysis/" rel="next">
          <span class="nav-title">AudioCraft Custom 프로젝트 완전 분석: AI 오디오 생성의 최첨단 기술</span>
          <i class="icon-right-arrow"></i>
        </a>
      </div></div>
  </footer>
  </article></div>

    </section>
    <footer class="condensed">
      <ul class="social about-footer condensed"><a href="https://github.com/leeyonghe" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://www.linkedin.com/in/lee-yong-hee-18912454/" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><!----></ul><p class="about-footer condensed">&copy;
        2025</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/ai-blog/assets/js/darkmode.js"></script>
  
  <script src="/ai-blog/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/ai-blog/assets/js/search.js"></script>
  
</body>

</html>
